use std::ops::gray2bin;
use std::ops::bin2gray;

mod unsafe {
    use std::ops::gray2bin;
    use std::ops::bin2gray;

    /// NOTE: This function does not provide any guarantees about value
    /// integrity for / signals of more than one bit as crossing 2 domains with
    /// multi-bit signals can cause issues.
    /// It is primariliy intended for other synchronization primitives
    entity sync2<T>(clk: clock, in: T) -> T {
        reg(clk) sync1 = in;
        reg(clk) sync2 = sync1;
        sync2
    }

    /// Synchronizes a uint counter signal between domains. *The counter*
    /// aspect is important, it must be a N bit gray counter for this to do
    /// anything useful.
    entity sync_uint_counter<#N>(source_clk: clock, dest_clk: clock, in: uint<N>) -> uint<N> {
        reg(source_clk) gray = bin2gray(in);
        gray2bin(inst sync2(dest_clk, gray))
    }
}

entity sync2_bool(clk: clock, in: bool) -> bool {
    inst unsafe::sync2(clk, in)
}


// Synchronize data from clk1 to clk2 via handshaking. Primarily to be used to cross
// domains of similar speed. A single pulse on data in clk1 results in a signle output in clk2.
// If data is active for more than one cycle, the behaviour is undefined. Likewise if
// data occurs too frequently, i.e. within a few clock cycles in the slowest domain
entity handshake<T>(clk1: clock, rst: bool, data: Option<T>, clk2: clock) -> Option<T> {
    decl ack_clk2;
    // NOTE: Since we only read the Option bit of this value, we're safe to use sync2
    let ack_clk1 = inst unsafe::sync2(clk1, ack_clk2);

    // Hold onto the data in the sending domain until the receiving domain has acknowledged that
    // it received
    reg(clk1) holder_clk1 reset(rst: None()) = match (data, holder_clk1, ack_clk1) {
        (Some(new), _, _) => Some(new),
        (_, Some(prev), false) => Some(prev),
        (_, Some(prev), true) => None(),
        (None, None, _) => None()
    };

    // NOTE: Since we only read the Option bit of this value, we're safe to use sync2
    let holder_clk2 = inst unsafe::sync2(clk2, holder_clk1);

    reg(clk2) ack_clk2 reset (rst: false) = match (ack_clk2, holder_clk2) {
        (false, None) => false,
        (false, Some(_)) => true,
        (true, None) => false,
        (true, Some(_)) => true,
    };

    match (ack_clk2, holder_clk2) {
        (false, Some(val)) => Some(val),
        _ => None()
    }
}


mod sync_wide_impl {
    use lib::cdc::sync2_bool;

    enum TxState<T> {
        Init,
        Setup{val: T},
        Hold{val: T},
        WaitRelease,
    }

    struct port FromSender<T> {
        valid: &bool,
        data: &T,
        ack: &mut bool,
    }

    entity sender<T>(source_clk: clock, rst: bool, data_in: T, to_tx: ~FromSender<T>) {
        let ack = inst sync2_bool(source_clk, *to_tx.ack);

        reg(source_clk) state reset(rst: TxState::Init) = match state {
            TxState::Init => TxState::Setup(data_in),
            TxState::Setup(data) => TxState::Hold(data),
            TxState::Hold(data) => if ack {TxState::WaitRelease} else {TxState::Hold(data)},
            TxState::WaitRelease => if !ack {TxState::Setup(data_in)} else {TxState::WaitRelease},
        };

        reg(source_clk) UNDEF = UNDEF;
        let (valid, data) = match state {
            TxState::Init => (false, UNDEF),
            TxState::Setup(data) => (false, data),
            TxState::Hold(data) => (true, data),
            TxState::WaitRelease => (false, UNDEF)
        };
        set to_tx.valid = valid;
        set to_tx.data = data;
    }

    enum RxState {
        WaitReceive,
        SendAck,
    }
    entity receiver<T>(dest_clk: clock, rst: bool, init: T, from_tx: FromSender<T>) -> T {
        let valid = inst sync2_bool(dest_clk, *from_tx.valid);
        // We don't have synchronization primitives here because we ensure that
        // by the time valid is set, this is stable. However, we're only allowed to read
        // it while valid is high, and before replying with ack
        let data = *from_tx.data;

        reg(dest_clk) state reset(rst: RxState::WaitReceive) = match state {
            RxState::WaitReceive => if valid {RxState::SendAck} else {state},
            RxState::SendAck => if !valid {RxState::WaitReceive} else {state},
        };

        reg(dest_clk) out reset(rst: init) = match (state, valid) {
            (RxState::WaitReceive, true) => data,
            _ => out
        };

        set from_tx.ack = match state {
            RxState::WaitReceive => false,
            RxState::SendAck => true,
        };

        out
    }
}

/// Synchronizes a wide value from the source domain into the destination domain.
/// This guarnatees that all values sent between the domains are valid, but 
/// some values may be skipped
entity sync_wide<T>(source_clk: clock, rst: bool, in: T, init: T, dest_clk: clock) -> T {
    let (from_tx, to_tx) = port;

    let _ = inst sync_wide_impl::sender$(source_clk, rst, data_in: in, to_tx);

    inst sync_wide_impl::receiver$(dest_clk, rst, from_tx, init)
}
