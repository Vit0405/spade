---
source: spade-tests/src/verilator_wrapper.rs
---
#include <sstream>
#include <bitset>
#if __has_include(<Vno_mangle.h>)
#include <Vno_mangle.h>
class no_mangle_spade_t;
class no_mangle_spade_t_i;
no_mangle_spade_t_i* init_no_mangle_spade_t_i(no_mangle_spade_t& t);
class no_mangle_spade_t_o;
no_mangle_spade_t_o* init_no_mangle_spade_t_o(no_mangle_spade_t* root);
class no_mangle_spade_t {
    public:
        no_mangle_spade_t(std::string spade_state, std::string spade_top, Vno_mangle* top)
            : s_ext(spade::setup_spade(spade_top, spade_state))
            , top(top)
            , i(init_no_mangle_spade_t_i(*this))
            , o(init_no_mangle_spade_t_o(this))
        {
        }
        no_mangle_spade_t_i* i;
        no_mangle_spade_t_o* o;
        rust::Box<spade::SimulationExt> s_ext;
        Vno_mangle* top;
        std::string output_string_fn() {
        std::bitset<0> bits = this->top->output___05F;
        std::stringstream ss;
        ss << bits;
        return ss.str();
        }
};
class no_mangle_spade_t_i_short {
    public:
        no_mangle_spade_t_i_short(no_mangle_spade_t& parent)
            : parent(parent)
        {}
        no_mangle_spade_t_i_short& operator=(std::string const& val) {
            auto value = parent.s_ext->port_value("short", val);
            parent.top->short_i = value->as_u64();
            return *this;
        }
    private:
        no_mangle_spade_t& parent;
};
class no_mangle_spade_t_i_wide {
    public:
        no_mangle_spade_t_i_wide(no_mangle_spade_t& parent)
            : parent(parent)
        {}
        no_mangle_spade_t_i_wide& operator=(std::string const& val) {
            auto value = parent.s_ext->port_value("wide", val);
            auto value_split = value->as_u32_chunks();
            parent.top->wide_i[0] = value_split[0];
            parent.top->wide_i[1] = value_split[1];
            parent.top->wide_i[2] = value_split[2];
            parent.top->wide_i[3] = value_split[3];
            return *this;
        }
    private:
        no_mangle_spade_t& parent;
};
class no_mangle_spade_t_i {
    public:
        no_mangle_spade_t_i(no_mangle_spade_t& parent)
            : parent(parent)
            , short(parent)
            , wide(parent)
        {}
        no_mangle_spade_t_i_short short;
        no_mangle_spade_t_i_wide wide;
    private:
        no_mangle_spade_t& parent;
};
no_mangle_spade_t_i* init_no_mangle_spade_t_i(no_mangle_spade_t& t) {
    return new no_mangle_spade_t_i(t);
}
class no_mangle_spade_t_o {
    public:
        no_mangle_spade_t_o(no_mangle_spade_t* root)
               : root(root) {}
        no_mangle_spade_t* root;
        bool operator==(std::string const& other) const {
            auto field = root->s_ext->output_field({});
            auto val = spade::new_bit_string(root->output_string_fn());
            return root
                     ->s_ext
                     ->compare_field(*field, other, *val)
                     ->matches();
        }
        void assert_eq(std::string const& expected, std::string const& source_loc) {
            auto field = root->s_ext->output_field({});
            auto val = spade::new_bit_string(root->output_string_fn());
            root
                ->s_ext
                ->assert_eq(*field, expected, *val, source_loc);
        }
};
no_mangle_spade_t_o* init_no_mangle_spade_t_o(no_mangle_spade_t* root) {
    return new no_mangle_spade_t_o(root);
}
#endif
