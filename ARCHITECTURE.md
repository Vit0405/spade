# Spade Compiler Architecture

Spade is split into several crates with the `main` function residing in
`spade-compiler`. However, this crate is mainly glue code for the code in the
other crates.

An overview of the compilation flow is shown below

<img style="width:100%;" src="misc/architecture.svg">

Each rounded rectangle is a step in the compilation process, which generally
lives in a crate with a similar name. Each blue "note" is an artefact, created
by one of these steps, which also usually resides in a similarly named crate.

Below is a short description of what each of the artefacts are for, followed by
a description of roughly how the passes work.

## Intermediate Representations

### AST (Abstract Syntax Tree)

The AST is a tree based representation of the program structure, free of any
details from the source code such as white space or comments. The structure of
the AST is guaranteed to be `valid`, i.e. you can not have a keyword in place
of an identifier, if statements have both a condition and a branch etc.


### HIR (High Level Intermediate Representation)

The structure of the HIR is similar to that of the AST, but the primary
difference is that name scoping and 'kind' has been checked here, and variables have
been replaced with IDs. The IDs `NameID(u64, String)` are a globally unique ID
assigned during AST lowering, along with a "descriptive name" to make debugging
the output code easier. There are no guarantees about this name.

All other rules of the language (apart from those which require type
information) are also guaranteed to be upheld in the HIR, for example, the
number of arguments to a function call is guaranteed correct.

### TypeSpec

The `TypeSpec` strut contains a mapping between the things (variables and
expressions) and their inferred types. All types are guaranteed correct if the
TypeSpec struct exists but they are not necessarily in their most concrete
form, generics can still exist

### MIR (Medium Level Intermediate Representation)

The MIR has lost almost all the structure of the program and therefore only consists of `entities` (and in the future, other top level constructs like pipelines and functions) which in turn are lists of `statements`. Statements `bindings` or `registers` where each `register` or `binding` has only one simple expression. For example, `let x = a + b + c` in HIR looks like

```rust
_0: Int<16> = a + b;
x: Int<16> = _0 + x;
```

MIR as generated by the compiler is guaranteed to be correct. It has no generic
types and no type errors. Error checking might be added, but these will cause a
panic and should never be visible to the user


## Passes

### Parser

The parser goes from input text to the AST. It does this in 2 phases: `lexing`
and `parsing`. Lexing converts characters to `tokens` and almost all of the
work is done by the `logos` crate. To add more tokens, they only need to be
added to the `TokenKind` enum.

The stream of tokens is parsed by the parser which is a hand written recursive
descent parser. Each AST node has roughly one parsing function which tries to
parse a node of that kind.

The `#[trace_parser]` proc macro automatically gives a traceback of a parse
session allowing easier debugging.

### Global collection

The global collection pass walks through modules in the AST, collecting items
at the top level, like entities, other modules, types etc. These are added to
the `symbol_table` in the outermost scope.

### AST Lowering

AST lowering checks program semantics to generate HIR. It does this by
recursively traversing the AST, replacing identifiers and paths with `NameID`'s.

Here, the names used are checked to be the right "kind" (`entity`, `type`, `variable`)
by looking them up in the symtab.

### Type inference

Type Inference works on the HIR and is based on a unification algorithm.
Whenever a new typed thing (sub-expression, variable etc.) is found, a new
"type variable" and "type equation" is added. When a typed thing is used, for
example as an operand, the type system "unifies" the type equations associated
with that type. For example `x + y` unifies `x` with `int` (for now, in the
future, it should be unified with any `Addable` type), and then `x` is unified
with `y` to ensure that the `lhs` and `rhs` match

### HIR Lowering

HIR lowering goes from HIR to MIR. Here, the tree structure of each entity is
flattened into a series of MIR statements. Each expression and variable is
assigned its own MIR statement and they are all concatenated together for the
whole entity. Use of generic parameters is detected and alerted to here.


### MIR codegen 

MIR codegen is the final step of the compilation process where the MIR code is
converted to verilog. Each MIR statement gets roughly one variable or register
along with an assignment of the correct value.



## Misc. useful stuff

Here is a description of a few things that are seen throughout the compiler

### The Loc<T> struct

Almost all language constructs stem from a location in the original source code
`Loc<T>` encodes this information in a way that is relatively easy to propagate
through the compiler.

It provides several methods to transform the internals while keeping the
information such as `map` `map_ref`, `try_map` and so on.

For example, a HIR lowering step generally looks like this to preserver location info:
```rust
fn visit_some_node(input: ast::SomeNode) -> Result<ast::SomeNode, Error> {
    //...
}

fn some_other_visitor(...) -> Result<..., Error> {
    let hir_some_node = some_node.try_map(visit_some_node)?;
    ...
}
```

### Error reporting

Error reporting is done using the `codespan` and `codespan_reporting` crate.
Each intermediate step defines its own `Error` type and has its own function
for printing that error using `codespan_reporting`.
