use std::collections::BTreeMap;

use local_impl::local_impl;
use spade_common::{location_info::Loc, name::NameID};
use spade_diagnostics::diag_bail;
use spade_diagnostics::Diagnostic;
use spade_hir::expression::CallKind;
use spade_hir::Binding;
use spade_hir::TypeSpec;
use spade_hir::{symbol_table::FrozenSymtab, ExprKind, Expression, ItemList, Pattern, Statement};
use spade_mir as mir;
use spade_typeinference::TypeState;

use crate::{
    error::Error, statement_list::StatementList, substitution::Substitutions, MirLowerable,
    NameIDExt, Result,
};

pub fn handle_pattern(pat: &Pattern, live_vars: &mut Vec<NameID>) {
    // Add this variable to the live vars list
    for name in pat.get_names() {
        live_vars.push(name.inner.clone());
    }
}

pub fn lower_pipeline<'a>(
    hir_inputs: &Vec<(Loc<NameID>, Loc<TypeSpec>)>,
    body: &Loc<Expression>,
    types: &TypeState,
    statements: &mut StatementList,
    subs: &mut Substitutions,
    symtab: &mut FrozenSymtab,
    item_list: &ItemList,
    // Map of names generated by codegen to the original name in the source code.
    name_map: &mut BTreeMap<NameID, NameID>,
) -> Result<()> {
    let clock = &hir_inputs[0].0;

    let (body_statements, _) = if let ExprKind::Block(block) = &body.kind {
        (&block.statements, &block.result)
    } else {
        panic!("Pipeline body was not a block");
    };

    for (name, _) in hir_inputs {
        let is_port = types
            .name_type(&name, symtab.symtab(), &item_list.types)?
            .is_port();

        subs.set_available(name.clone(), 0, is_port)
    }

    for statement in body_statements {
        match &statement.inner {
            Statement::Binding(Binding {
                pattern,
                ty: _,
                value,
                wal_trace: _,
            }) => {
                let time = value.inner.kind.available_in()?;
                for name in pattern.get_names() {
                    let is_port = types
                        .name_type(&name, symtab.symtab(), &item_list.types)?
                        .is_port();

                    subs.set_available(name, time, is_port)
                }
            }
            Statement::Register(reg) => {
                let time = reg.inner.value.kind.available_in()?;
                for name in reg.pattern.get_names() {
                    let is_port = types
                        .name_type(&name, symtab.symtab(), &item_list.types)?
                        .is_port();
                    subs.set_available(name, time, is_port)
                }
            }
            Statement::Declaration(_) => todo!(),
            Statement::PipelineRegMarker(cond) => {
                if cond.is_some() {
                    // TODO
                    todo!("Implement stage conditions")
                }
                let live_vars = subs.next_stage(symtab);

                // Generate pipeline regs for previous live vars
                for reg in &live_vars {
                    if name_map
                        .insert(reg.new.clone(), reg.original.inner.clone())
                        .is_some()
                    {
                        // NOTE: Panic because this should not occur in user code
                        panic!("inserted duplicate in name map");
                    }

                    statements.push_secondary(
                        mir::Statement::Register(mir::Register {
                            name: reg.new.value_name(),
                            ty: types
                                .name_type(&reg.original, symtab.symtab(), &item_list.types)?
                                .to_mir_type(),
                            clock: clock.value_name(),
                            reset: None,
                            value: reg.previous.value_name(),
                            // NOTE: Do we/can we also want to point to the declaration
                            // of the variable?
                            loc: Some(statement.loc()),
                            traced: None,
                        }),
                        &reg.original,
                        "Pipelined",
                    );
                }
            }
            Statement::Label(_) => {
                // Labels have no effect on codegen
            }
            Statement::Assert(_) => {
                // Assertions have no effect on pipeline state
            }
            Statement::Set { .. } => {
                // Set have no effect on pipeline state
            }
        }
    }

    Ok(())
}

/// Computes the time at which the specified expressions will be available. If there
/// is a mismatch, an error is returned
pub fn try_compute_availability(
    exprs: &[impl std::borrow::Borrow<Loc<Expression>>],
) -> Result<usize> {
    let mut result = None;
    for expr in exprs {
        let a = expr.borrow().kind.available_in()?;

        result = match result {
            None => Some(a),
            Some(prev) if a == prev => result,
            // NOTE: Safe index. This branch can only be reached in iteration 2 of the loop
            _ => {
                return Err(Error::AvailabilityMismatch {
                    prev: exprs[0].borrow().clone().map(|_| result.unwrap()),
                    new: expr.borrow().clone().map(|_| a),
                })
            }
        }
    }
    Ok(result.unwrap_or(0))
}

#[local_impl]
impl PipelineAvailability for ExprKind {
    fn available_in(&self) -> Result<usize> {
        match self {
            ExprKind::Identifier(_) => Ok(0),
            ExprKind::IntLiteral(_) => Ok(0),
            ExprKind::BoolLiteral(_) => Ok(0),
            ExprKind::CreatePorts => Ok(0),
            ExprKind::TupleLiteral(inner) => try_compute_availability(inner),
            ExprKind::ArrayLiteral(elems) => try_compute_availability(elems),
            ExprKind::Index(lhs, idx) => try_compute_availability(&[lhs.as_ref(), idx.as_ref()]),
            ExprKind::TupleIndex(lhs, _) => lhs.inner.kind.available_in(),
            ExprKind::FieldAccess(lhs, _) => lhs.inner.kind.available_in(),
            ExprKind::BinaryOperator(lhs, _, rhs) => {
                try_compute_availability(&[lhs.as_ref(), rhs.as_ref()])
            }
            ExprKind::UnaryOperator(_, val) => val.inner.kind.available_in(),
            ExprKind::Match(_, values) => {
                try_compute_availability(&values.iter().map(|(_, expr)| expr).collect::<Vec<_>>())
            }
            ExprKind::Block(inner) => {
                // NOTE: Do we want to allow delayed values inside blocks? That could lead to some
                // strange issues like
                // {
                //      let x = inst(10) subpipe();
                //      x // Will appear as having availability 1
                // }
                inner.result.kind.available_in()
            }
            ExprKind::Call {
                kind: CallKind::Pipeline(_, depth),
                ..
            } => {
                // FIXME: Re-add this check to allow nested pipelines
                // let arg_availability = try_compute_availability(
                //     &args.iter().map(|arg| &arg.value).collect::<Vec<_>>(),
                // )?;
                Ok(depth.inner as usize)
            }
            ExprKind::Call {
                kind: CallKind::Function,
                ..
            }
            | ExprKind::Call {
                kind: CallKind::Entity(_),
                ..
            } => Ok(0),
            ExprKind::If(_, t, f) => try_compute_availability(&[t.as_ref(), f.as_ref()]),
            ExprKind::PipelineRef { .. } => Ok(0),
            ExprKind::MethodCall { name, .. } => diag_bail!(
                name,
                "Method call should already have been lowered by this point"
            ),
            ExprKind::Null => {
                panic!("Null expression during pipeline lowering")
            }
        }
    }
}
