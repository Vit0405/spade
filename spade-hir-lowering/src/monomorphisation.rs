use std::collections::{BTreeMap, VecDeque};

use spade_common::{id_tracker::ExprIdTracker, location_info::WithLocation, name::NameID};
use spade_diagnostics::{DiagHandler, Diagnostic};
use spade_hir::{symbol_table::FrozenSymtab, ExecutableItem, ItemList, UnitName};
use spade_mir as mir;
use spade_typeinference::equation::TypeVar;
use spade_typeinference::error::UnificationErrorExt;
use spade_typeinference::{GenericListToken, TypeState};
use spade_wordlength_inference as wordlength_inference;

use crate::error::{Error, Result};
use crate::generate_unit;
use crate::name_map::NameSourceMap;
use crate::passes::lower_methods::LowerMethods;
use crate::passes::pass::Passable;

/// An item to be monomorphised
struct MonoItem {
    /// The name of the original item which this is a monomorphised version of
    pub source_name: NameID,
    /// The new name of the new item
    pub new_name: UnitName,
    /// The types to replace the generic types in the item. Positional replacement
    pub params: Vec<TypeVar>,
}

pub struct MonoState {
    /// List of mono items left to compile
    to_compile: VecDeque<MonoItem>,
    /// Mapping between items with types specified and names
    translation: BTreeMap<(NameID, Vec<TypeVar>), NameID>,
}

impl Default for MonoState {
    fn default() -> Self {
        Self::new()
    }
}

impl MonoState {
    pub fn new() -> MonoState {
        MonoState {
            to_compile: VecDeque::new(),
            translation: BTreeMap::new(),
        }
    }

    /// Request compilation of a unit with the specified type parameters, returning the name of the
    /// unit which will be compiled with these parameters. It is up to the caller of this
    /// function to ensure that the type params are valid for this item.
    pub fn request_compilation(
        &mut self,
        source_name: UnitName,
        reuse_nameid: bool,
        params: Vec<TypeVar>,
        symtab: &mut FrozenSymtab,
    ) -> NameID {
        match self
            .translation
            .get(&(source_name.name_id().inner.clone(), params.clone()))
        {
            Some(prev) => prev.clone(),
            None => {
                let new_name = if reuse_nameid {
                    source_name.name_id().inner.clone()
                } else {
                    symtab.new_name(source_name.name_id().1.clone())
                };

                // Wrap the new name in a UnitName to match the source. Previous steps
                // ensure that the unit name is general enough to not cause name collisions
                let new_unit_name = match &source_name {
                    UnitName::WithID(_) => UnitName::WithID(new_name.clone().nowhere()),
                    UnitName::FullPath(_) => UnitName::FullPath(new_name.clone().nowhere()),
                    UnitName::Unmangled(source, _) => {
                        UnitName::Unmangled(source.clone(), new_name.clone().nowhere())
                    }
                };

                self.to_compile.push_back(MonoItem {
                    source_name: source_name.name_id().inner.clone(),
                    new_name: new_unit_name,
                    params,
                });
                new_name
            }
        }
    }

    fn next_target(&mut self) -> Option<MonoItem> {
        self.to_compile.pop_front()
    }
}

pub struct MirOutput {
    pub mir: mir::Entity,
    pub type_state: TypeState,
    /// Mapping between new names for registers and their previous value. Used
    /// to add type information for registers generated by pipelines
    pub reg_name_map: BTreeMap<NameID, NameID>,
}

pub fn compile_items(
    items: &BTreeMap<&NameID, (&ExecutableItem, TypeState)>,
    symtab: &mut FrozenSymtab,
    idtracker: &mut ExprIdTracker,
    name_source_map: &mut NameSourceMap,
    item_list: &ItemList,
    diag_handler: &mut DiagHandler,
    wordlength_inference_method: Option<wordlength_inference::InferMethod>,
) -> Vec<Result<MirOutput>> {
    // Build a map of items to use for compilation later. Also push all non
    // generic items to the compilation queue

    let mut state = MonoState::new();

    for (item, _) in items.values() {
        match item {
            ExecutableItem::Unit(u) => {
                if u.head.type_params.is_empty() {
                    state.request_compilation(u.name.clone(), true, vec![], symtab);
                }
            }
            ExecutableItem::StructInstance => {}
            ExecutableItem::EnumInstance { .. } => {}
            ExecutableItem::BuiltinUnit(_, _) => {}
        }
    }

    let mut result = vec![];
    while let Some(item) = state.next_target() {
        let original_item = items.get(&item.source_name);

        let mut reg_name_map = BTreeMap::new();
        match original_item {
            Some((ExecutableItem::Unit(u), old_type_state)) => {
                let type_ctx = &spade_typeinference::Context {
                    symtab: symtab.symtab(),
                    items: item_list,
                };
                let mut type_state = old_type_state.clone();
                if !u.head.type_params.is_empty() {
                    let generic_list = type_state
                        .get_generic_list(&GenericListToken::Definition(
                            u.name.name_id().inner.clone(),
                        ))
                        .clone();

                    for (source_param, new) in u.head.type_params.iter().zip(item.params.iter()) {
                        let source_var = &generic_list[&source_param.name_id()];

                        match type_state
                            .unify(new, source_var, type_ctx)
                            .into_default_diagnostic(u)
                        {
                            Ok(_) => {}
                            Err(e) => {
                                result.push(Err(Error::SpadeDiagnostic(e)));
                            }
                        }
                    }
                }
                if !type_state.get_constraints().inner.is_empty() {
                    result.push(Err(Diagnostic::bug(
                        item.new_name.name_id(),
                        "Some type constraints remain after monomorphization",
                    )
                    .into()));
                    continue;
                }

                // Apply passes to the type checked module
                let mut u = u.clone();
                let pass_result = u.apply(&mut LowerMethods {
                    type_state: &type_state,
                    items: item_list,
                    symtab,
                });
                if let Err(e) = pass_result {
                    result.push(Err(e));
                    continue;
                }

                if let Some(method) = wordlength_inference_method {
                    let infer_result = wordlength_inference::infer_and_check(
                        method,
                        &mut type_state,
                        &u,
                        type_ctx,
                    );
                    if let Err(e) = infer_result {
                        result.push(Err(Error::SpadeDiagnostic(e)));
                        continue;
                    }
                }

                let out = generate_unit(
                    &u.inner,
                    item.new_name,
                    &mut type_state,
                    symtab,
                    idtracker,
                    item_list,
                    &mut reg_name_map,
                    &mut state,
                    diag_handler,
                    name_source_map,
                )
                .map(|mir| MirOutput {
                    mir,
                    type_state: type_state.clone(),
                    reg_name_map,
                });
                result.push(out);
            }
            Some((ExecutableItem::StructInstance, _)) => {
                panic!("Requesting compilation of struct instance as module")
            }
            Some((ExecutableItem::EnumInstance { .. }, _)) => {
                panic!("Requesting compilation of enum instance as module")
            }
            Some((ExecutableItem::BuiltinUnit(_, _), _)) => {
                panic!("Requesting compilation of builtin unit")
            }
            None => {
                panic!(
                    "Requesting compilation of {} but no such item is present",
                    item.source_name
                )
            }
        }
    }
    result
}
