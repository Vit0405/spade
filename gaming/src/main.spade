entity tick_gen(clk: clk, rst: bool, tick_length: int<32>) -> bool {
    reg(clk) timer reset (rst: 0) = if timer == tick_length then {
        0
    } else {
        timer + 1
    };

    timer == tick_length
}

entity pwm(clk: clk, rst: bool, duty_cycle: int<8>) -> bool {
    reg(clk) timer reset (rst: 0) = {
        timer + 1
    };
    timer < duty_cycle
}

entity pulse_led(clk: clk, rst: bool, tick_len: int<32>, max: int<8>, start: int<8>) -> bool {
    let tick = inst tick_gen(clk, rst, tick_len);

    reg(clk) state: (int<8>, bool) reset (rst: (start, false)) = {
        let duty = state#0;
        let dir = state#1;

        let new_dir =
            if duty == max then {
                true
            }
            else if duty == 0 then {
                false
            }
            else {
                dir
            };

        let new_duty =
            if tick then {
                if dir then duty - 1 else duty + 1
            }
            else {
                duty
            };

        (new_duty, new_dir)
    };

    let duty = state#0;
    inst pwm(clk, rst, duty)
}

entity rgb_pulse(clk: clk, rst: bool, start_offset: int<8>) -> (bool, bool, bool) {
    let tick_len_r = 80_000 << 1;
    let tick_len_g = 100_000 << 4 << 1;
    let tick_len_b = 120_000 << 4 << 1;

    (
        inst pulse_led(clk, rst, tick_len_b, 32, start_offset >> 4),
        inst pulse_led(clk, rst, tick_len_g, 32, start_offset >> 4),
        inst pulse_led(clk, rst, tick_len_r, 255, start_offset)
    )
}

entity pong(clk: clk, rst: bool) -> (
    (bool, bool, bool),
    (bool, bool, bool),
    (bool, bool, bool),
    (bool, bool, bool)
) {
    (
        inst rgb_pulse(clk, rst, 0),
        inst rgb_pulse(clk, rst, 64),
        inst rgb_pulse(clk, rst, 128),
        inst rgb_pulse(clk, rst, 128+64),
    )
}
