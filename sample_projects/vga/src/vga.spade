enum VgaPartialState {
    BackPorch(duration: int<10>),
    Active(duration: int<10>),
    FrontPorch(duration: int<10>),
    Sync(duration: int<10>),
}

entity vga_partial_fsm(
    clk: clk,
    rst: bool,
    // True if this should tick over to the next state
    next_state: bool,
    // Timings
    front_porch: int<10>,
    active: int<10>,
    sync: int<10>,
    back_porch: int<10>,
) -> (bool, VgaPartialState) {
    reg(clk) state reset(rst: VgaPartialState::BackPorch(0)) = {
        if next_state {
            match state {
                VgaPartialState::BackPorch(duration) => {
                    if duration == back_porch {
                        VgaPartialState::Active(0)
                    }
                    else {
                        VgaPartialState::BackPorch(duration + 1)
                    }
                },
                VgaPartialState::Active(duration) => {
                    if duration == active {
                        VgaPartialState::FrontPorch(0)
                    }
                    else {
                        VgaPartialState::Active(duration + 1)
                    }
                },
                VgaPartialState::FrontPorch(duration) => {
                    if duration == front_porch {
                        VgaPartialState::Sync(0)
                    }
                    else {
                        VgaPartialState::FrontPorch(duration + 1)
                    }
                },
                VgaPartialState::Sync(duration) => {
                    if duration == sync {
                        VgaPartialState::BackPorch(0)
                    }
                    else {
                        VgaPartialState::Sync(duration + 1)
                    }
                },
            }
        }
        else {
            state
        }
    };

    let carry_out = match state {
        VgaPartialState::Sync(duration) => {
            if duration == sync {
                next_state
            }
            else {
                false
            }
        },
        _ => false
    };

    (carry_out, state)
}

entity vga_fsm(clk: clk, rst: bool) -> (VgaPartialState, VgaPartialState) {
    reg(clk) clk_div: int<3> reset (rst: 0) = {
        if clk_div == 3 {
            0
        }
        else {
            clk_div + 1
        }
    };

    let vga_clk = clk_div == 1;

    let x_pixels = 640;
    let x_front_porch = 16;
    let x_sync_width = 96;
    let x_back_porch = 48;

    let y_pixels = 480;
    let y_front_porch = 10;
    let y_sync_width = 2;
    let y_back_porch = 33;

    let (next_y, x_state) = inst vga_partial_fsm(
        clk,
        rst,
        vga_clk,
        x_front_porch,
        x_pixels,
        x_sync_width,
        x_back_porch
    );

    let (_, y_state) = inst vga_partial_fsm(
        clk,
        rst,
        next_y,
        y_front_porch,
        y_pixels,
        y_sync_width,
        y_back_porch
    );

    (x_state, y_state)
}

entity vga_output(vga_state: (VgaPartialState, VgaPartialState))
    -> (bool, bool, Option<(int<10>, int<10>)>)
{
    let pixel = match vga_state {
        (VgaPartialState::Active(x), VgaPartialState::Active(y)) => Option::Some((x, y)),
        _ => Option::None()
    };

    let hsync = match vga_state#0 {
        VgaPartialState::Sync(_) => false,
        _ => true
    };

    let vsync = match vga_state#1 {
        VgaPartialState::Sync(_) => false,
        _ => true
    };

    (hsync, vsync, pixel)
}

entity vga_frame_done(state: (VgaPartialState, VgaPartialState)) -> bool {
    match state {
        (VgaPartialState::FrontPorch(x), VgaPartialState::FrontPorch(y)) => {
            if x == 0 && y == 0 {
                true
            }
            else {
                false
            }
        },
        _ => false
    }
}
